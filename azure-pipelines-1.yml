trigger:
  branches:
    include:
      - master

pool:
  vmImage: 'ubuntu-latest'

variables:
  PROJECT_NAME: 'uptimestars'
  SONAR_PROJECT_KEY: 'starsteam_starsteam123'
  SONAR_ORGANIZATION: 'StarsTeam'

steps:

# ğŸ”§ Instalar .NET 8 SDK
- task: UseDotNet@2
  displayName: 'ğŸ”§ Instalar .NET 8 SDK'
  inputs:
    packageType: 'sdk'
    version: '8.0.x'

# ğŸ” Instalar dotnet-sonarscanner
- script: |
    dotnet tool install --global dotnet-sonarscanner
  displayName: 'ğŸ” Instalar SonarScanner .NET'

# ğŸš€ Iniciar anÃ¡lisis SonarCloud
- script: |
    dotnet sonarscanner begin \
      /k:"$(SONAR_PROJECT_KEY)" \
      /o:"$(SONAR_ORGANIZATION)" \
      /d:sonar.token="$SONAR_TOKEN" \
      /d:sonar.cs.opencover.reportsPaths="$(Build.ArtifactStagingDirectory)/TestResults/**/coverage.opencover.xml"
  displayName: 'ğŸš€ Iniciar anÃ¡lisis SonarCloud'
  env:
    SONAR_TOKEN: $(SONAR_TOKEN)

# ğŸ§ª Ejecutar pruebas unitarias con cobertura
- script: |
    echo "ğŸ§ª Ejecutando pruebas unitarias..."
    dotnet test Uptime.Stars.Backend/Uptime.Stars.UnitTests/Uptime.Stars.UnitTests.csproj \
      --configuration Release \
      --logger "trx;LogFileName=test-results.trx" \
      --results-directory "$(Build.ArtifactStagingDirectory)/TestResults" \
      --collect:"XPlat Code Coverage"
  displayName: 'ğŸ§ª Ejecutar pruebas unitarias'

# ğŸ§¹ Finalizar anÃ¡lisis SonarCloud
- script: |
    dotnet sonarscanner end /d:sonar.token="$SONAR_TOKEN"
  displayName: 'ğŸ§¹ Finalizar anÃ¡lisis SonarCloud'
  env:
    SONAR_TOKEN: $(SONAR_TOKEN)

# ğŸ“Š Publicar resultados de pruebas
- task: PublishTestResults@2
  displayName: 'ğŸ“Š Publicar resultados de pruebas'
  inputs:
    testResultsFormat: 'VSTest'
    testResultsFiles: '$(Build.ArtifactStagingDirectory)/TestResults/*.trx'
    failTaskOnFailedTests: true

# ğŸ“ˆ Publicar cobertura de cÃ³digo
- task: PublishCodeCoverageResults@2
  displayName: 'ğŸ“ˆ Publicar cobertura de cÃ³digo'
  inputs:
    codeCoverageTool: 'Cobertura'
    summaryFileLocation: '$(Build.ArtifactStagingDirectory)/TestResults/**/coverage.cobertura.xml'

# ğŸ“¦ Publicar artefactos: resultados + cobertura
- task: PublishBuildArtifacts@1
  displayName: 'ğŸ“¦ Publicar artefactos'
  inputs:
    PathtoPublish: '$(Build.ArtifactStagingDirectory)/TestResults'
    ArtifactName: 'test-results'
    publishLocation: 'Container'

# âœ… Verificar rama
- script: |
    echo "âœ… Ejecutando pipeline en rama: $(Build.SourceBranch)"
  displayName: 'Mostrar rama actual'

# ğŸ” DiagnÃ³stico bÃ¡sico
- script: |
    echo "ğŸ” DiagnÃ³stico inicial"
    docker --version
    find . -name "docker-compose.yml"
  displayName: 'Verificar entorno y archivos'

# ğŸ³ Ejecutar docker-compose
- task: DockerCompose@1
  displayName: 'ğŸ³ Build & Run Docker Compose'
  inputs:
    containerregistrytype: 'Container Registry'
    dockerComposeFile: 'Uptime.Stars.Backend/docker-compose.yml'
    action: 'Run services'
    projectName: '$(PROJECT_NAME)'
    buildImages: true

# â³ Esperar servicios
- script: |
    echo "â³ Esperando arranque de servicios..."
    sleep 20
  displayName: 'Delay para servicios'

# ğŸ©º Verificar endpoint /healthz
- script: |
    echo "ğŸŒ Verificando acceso a la API en http://localhost:8080"
    curl -sf http://localhost:8080/healthz || (echo "âŒ API no responde" && exit 1)
  displayName: 'Verificar endpoint /healthz'

# ğŸ“„ Mostrar logs de contenedor
- script: |
    echo "ğŸ“¦ Contenedores activos:"
    docker ps -a

    echo "ğŸ“„ Logs del contenedor uptime.stars.api:"
    docker logs $(docker ps -aqf "name=uptime.stars.api" || true)
  displayName: 'Mostrar logs de contenedor API'
  condition: always()
